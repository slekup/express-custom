#!/usr/bin/env node
const fileTimeStart = Date.now();
import fs from 'fs';
import path from 'path';
import getRawConfig from './utils/getRawConfig';
import loadApi from './utils/loadApi';
import logInfo from './utils/logInfo';
import logger, { cli } from './utils/logger';
/**
 * Export the API data to a JSON file.
 * @param apiData The API data.
 */
const exportApi = async (apiData) => {
    const timeStart = Date.now();
    logger.info(`${cli.inf} Exporting API data to JSON file`);
    const targetPath = path.join(process.cwd(), apiData.output);
    try {
        // Make ouput directory if it doesn't exist
        if (!fs.existsSync(targetPath))
            await fs.promises.mkdir(targetPath, {
                recursive: true,
            });
        // Write the API data to a JSON file in the out directory
        await fs.promises.writeFile(path.join(targetPath, `./api.json`), JSON.stringify(apiData, null, 2));
        // fs.promises.unlink(path.join(__dirname, `./api.json`));
        const time = `${Date.now() - timeStart}ms`;
        logger.info(`${cli.suc} âš¡ Exported API data in ${time}`);
    }
    catch (error) {
        logger.error(`${cli.err} Failed to export API data to JSON file`);
        logger.info(error);
    }
};
/**
 * The main function.
 */
const main = async () => {
    const rawConfig = await getRawConfig();
    const apiData = await loadApi(rawConfig.file);
    await exportApi(apiData);
    logInfo(apiData, fileTimeStart, 'Exported API to JSON');
    process.exit(1);
};
main();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0LWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9iaW4vZXhwb3J0LWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBRUEsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBRWpDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFHeEIsT0FBTyxZQUFZLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxPQUFPLE1BQU0saUJBQWlCLENBQUM7QUFDdEMsT0FBTyxPQUFPLE1BQU0saUJBQWlCLENBQUM7QUFDdEMsT0FBTyxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3Qzs7O0dBR0c7QUFDSCxNQUFNLFNBQVMsR0FBRyxLQUFLLEVBQUUsT0FBb0IsRUFBaUIsRUFBRTtJQUM5RCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLGtDQUFrQyxDQUFDLENBQUM7SUFFMUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRTVELElBQUk7UUFDRiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO1lBQzVCLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO2dCQUNsQyxTQUFTLEVBQUUsSUFBSTthQUNoQixDQUFDLENBQUM7UUFFTCx5REFBeUQ7UUFDekQsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLEVBQ25DLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FDakMsQ0FBQztRQUVGLDBEQUEwRDtRQUUxRCxNQUFNLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxTQUFTLElBQUksQ0FBQztRQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsMkJBQTJCLElBQUksRUFBRSxDQUFDLENBQUM7S0FDMUQ7SUFBQyxPQUFPLEtBQUssRUFBRTtRQUNkLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyx5Q0FBeUMsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDcEI7QUFDSCxDQUFDLENBQUM7QUFFRjs7R0FFRztBQUNILE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBbUIsRUFBRTtJQUNyQyxNQUFNLFNBQVMsR0FBRyxNQUFNLFlBQVksRUFBRSxDQUFDO0lBQ3ZDLE1BQU0sT0FBTyxHQUFHLE1BQU0sT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxNQUFNLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN6QixPQUFPLENBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDO0FBRUYsSUFBSSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5cbmNvbnN0IGZpbGVUaW1lU3RhcnQgPSBEYXRlLm5vdygpO1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IEV4cG9ydGVkQXBpIH0gZnJvbSAnQHR5cGluZ3MvZXhwb3J0cyc7XG5pbXBvcnQgZ2V0UmF3Q29uZmlnIGZyb20gJy4vdXRpbHMvZ2V0UmF3Q29uZmlnJztcbmltcG9ydCBsb2FkQXBpIGZyb20gJy4vdXRpbHMvbG9hZEFwaSc7XG5pbXBvcnQgbG9nSW5mbyBmcm9tICcuL3V0aWxzL2xvZ0luZm8nO1xuaW1wb3J0IGxvZ2dlciwgeyBjbGkgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBBUEkgZGF0YSB0byBhIEpTT04gZmlsZS5cbiAqIEBwYXJhbSBhcGlEYXRhIFRoZSBBUEkgZGF0YS5cbiAqL1xuY29uc3QgZXhwb3J0QXBpID0gYXN5bmMgKGFwaURhdGE6IEV4cG9ydGVkQXBpKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHRpbWVTdGFydCA9IERhdGUubm93KCk7XG4gIGxvZ2dlci5pbmZvKGAke2NsaS5pbmZ9IEV4cG9ydGluZyBBUEkgZGF0YSB0byBKU09OIGZpbGVgKTtcblxuICBjb25zdCB0YXJnZXRQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIGFwaURhdGEub3V0cHV0KTtcblxuICB0cnkge1xuICAgIC8vIE1ha2Ugb3VwdXQgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmModGFyZ2V0UGF0aCkpXG4gICAgICBhd2FpdCBmcy5wcm9taXNlcy5ta2Rpcih0YXJnZXRQYXRoLCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgLy8gV3JpdGUgdGhlIEFQSSBkYXRhIHRvIGEgSlNPTiBmaWxlIGluIHRoZSBvdXQgZGlyZWN0b3J5XG4gICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKFxuICAgICAgcGF0aC5qb2luKHRhcmdldFBhdGgsIGAuL2FwaS5qc29uYCksXG4gICAgICBKU09OLnN0cmluZ2lmeShhcGlEYXRhLCBudWxsLCAyKVxuICAgICk7XG5cbiAgICAvLyBmcy5wcm9taXNlcy51bmxpbmsocGF0aC5qb2luKF9fZGlybmFtZSwgYC4vYXBpLmpzb25gKSk7XG5cbiAgICBjb25zdCB0aW1lID0gYCR7RGF0ZS5ub3coKSAtIHRpbWVTdGFydH1tc2A7XG4gICAgbG9nZ2VyLmluZm8oYCR7Y2xpLnN1Y30g4pqhIEV4cG9ydGVkIEFQSSBkYXRhIGluICR7dGltZX1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoYCR7Y2xpLmVycn0gRmFpbGVkIHRvIGV4cG9ydCBBUEkgZGF0YSB0byBKU09OIGZpbGVgKTtcbiAgICBsb2dnZXIuaW5mbyhlcnJvcik7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIG1haW4gZnVuY3Rpb24uXG4gKi9cbmNvbnN0IG1haW4gPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IHJhd0NvbmZpZyA9IGF3YWl0IGdldFJhd0NvbmZpZygpO1xuICBjb25zdCBhcGlEYXRhID0gYXdhaXQgbG9hZEFwaShyYXdDb25maWcuZmlsZSk7XG4gIGF3YWl0IGV4cG9ydEFwaShhcGlEYXRhKTtcbiAgbG9nSW5mbyhhcGlEYXRhLCBmaWxlVGltZVN0YXJ0LCAnRXhwb3J0ZWQgQVBJIHRvIEpTT04nKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufTtcblxubWFpbigpO1xuIl19