{"version":3,"sources":["../src/index.ts","../src/utils/logger.ts","../src/utils/validate/tests.ts","../src/utils/validate/validate.ts","../src/utils/middleware/wrapper.middleware.ts","../src/builders/EndpointBuilder.ts","../src/builders/RouteBuilder.ts","../src/builders/SchemaBuilder.ts"],"sourcesContent":["import dotenv from 'dotenv';\r\nimport express from 'express';\r\n\r\ndotenv.config();\r\n\r\nexport * from './builders';\r\n\r\nexport default express;\r\n","import colors from 'colors';\r\nimport { TransformableInfo } from 'logform';\r\nimport * as winston from 'winston';\r\n\r\nconst debug = process.env.DEBUG ? true : false;\r\n\r\n/**\r\n * Returns a color based on the log level.\r\n * @param level The log level.\r\n * @returns The colored log level.\r\n */\r\nconst levelColor = (level: string): string => {\r\n  switch (level) {\r\n    case 'error': {\r\n      return colors.red(level.toUpperCase());\r\n    }\r\n    case 'warn': {\r\n      return colors.yellow(level.toUpperCase());\r\n    }\r\n    case 'info': {\r\n      return colors.green(level.toUpperCase());\r\n    }\r\n    case 'debug': {\r\n      return colors.blue(level.toUpperCase());\r\n    }\r\n    case 'trace': {\r\n      return colors.magenta(level.toUpperCase());\r\n    }\r\n    default: {\r\n      return colors.white(level.toUpperCase());\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * The format for the console transport.\r\n */\r\nconst consoleFormat = winston.format.combine(\r\n  // winston.format.prettyPrint(),\r\n  winston.format.colorize(),\r\n  winston.format.timestamp(),\r\n  winston.format.ms(),\r\n  winston.format.errors({ stack: true }),\r\n  // winston.format.splat(),\r\n  // winston.format.json(),\r\n  winston.format.printf(({ timestamp, ms, level, message, stack }: TransformableInfo) => {\r\n    let msg = message as string;\r\n\r\n    // Append the stack trace to the message if it is present\r\n    if (stack) msg += `\\n${stack as string}`;\r\n\r\n    /* eslint-disable no-control-regex */\r\n    const ANSI_REGEX = /\\u001b\\[[0-9]{1,2}m/gi;\r\n\r\n    return `${colors.gray(timestamp as string)} (${colors.magenta(ms as string)}) [${levelColor(\r\n      level.replace(ANSI_REGEX, '')\r\n    )}]: ${msg}`;\r\n  })\r\n);\r\n\r\n/**\r\n * The logger instance - console transports only.\r\n */\r\nconst logger = winston.createLogger({\r\n  level: 'debug',\r\n  format: consoleFormat,\r\n  transports: [\r\n    // Console transport\r\n    new winston.transports.Console({\r\n      level: debug ? 'debug' : 'info',\r\n    }),\r\n    new winston.transports.Console({\r\n      level: 'error',\r\n    }),\r\n    new winston.transports.Console({\r\n      level: 'warn',\r\n    }),\r\n    new winston.transports.Console({\r\n      level: 'trace',\r\n    }),\r\n  ],\r\n});\r\n\r\nexport default logger;\r\n","/**\r\n * Tests if a string is empty.\r\n * @param str The string to test.\r\n * @returns True if the string is empty, false otherwise.\r\n */\r\nexport const email = (str: string): boolean => {\r\n  // /^\\S+@\\S+\\.\\S+$/\r\n  // /\\S+@\\S+\\.\\S+/\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(str);\r\n};\r\n\r\n/**\r\n * Tests if a username is valid.\r\n * @param str The username to test.\r\n * @returns True if the username is valid, false otherwise.\r\n */\r\nexport const username = (str: string): boolean => {\r\n  const usernameRegex = /^[a-zA-Z0-9_]{3,16}$/;\r\n  return usernameRegex.test(str);\r\n};\r\n\r\n/**\r\n * Tests if a password is valid.\r\n * @param str The password to test.\r\n * @returns True if the password is valid, false otherwise.\r\n */\r\nexport const password = (str: string): boolean => {\r\n  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$/;\r\n  return passwordRegex.test(str);\r\n};\r\n\r\n/**\r\n * Tests if a phone number is valid.\r\n * @param str The phone number to test.\r\n * @returns True if the phone number is valid, false otherwise.\r\n */\r\nexport const phone = (str: string): boolean => {\r\n  const phoneNumberRegex = /^\\d{10}$/;\r\n  return phoneNumberRegex.test(str);\r\n};\r\n\r\n/**\r\n * Tests if a ipv4 address is valid.\r\n * @param str The IPv4 address to test.\r\n * @returns True if the IPv4 address is valid, false otherwise.\r\n */\r\nexport const ipv4Address = (str: string): boolean => {\r\n  // ^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$ - https://stackoverflow.com/questions/5284147/validating-ipv4-addresses-with-regexp\r\n  const ipv4AddressRegex = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}$/;\r\n  return ipv4AddressRegex.test(str);\r\n};\r\n\r\n/**\r\n * Tests if a color is valid.\r\n * @param color The color string to test.\r\n * @returns True if the color is valid, false otherwise.\r\n */\r\nexport const color = (color: string): boolean => {\r\n  // Remove any whitespace from the input\r\n  const cleanedColor = color.replace(/\\s/g, '');\r\n\r\n  // Check if the input matches a valid hex color pattern\r\n  if (/^#?[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/.test(cleanedColor)) {\r\n    // If it does, add a '#' if it's missing and return the cleanedColor\r\n    return cleanedColor.startsWith('#');\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Tests if a url is valid.\r\n * @param url The url to test.\r\n * @returns True if the url is valid, false otherwise.\r\n */\r\nexport const url = (url: string): boolean => {\r\n  // Check if the url is valid\r\n  try {\r\n    const urlObject = new URL(url);\r\n    return urlObject.href === url; // Additional check to handle relative URLs\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Tests if an image is valid.\r\n * @param image The image to test.\r\n * @returns True if the image is valid, false otherwise.\r\n */\r\nexport const image = (image: string): boolean => {\r\n  // Check if the image is valid\r\n  try {\r\n    const imageObject = new URL(image);\r\n    return imageObject.href === image; // Additional check to handle relative URLs\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n};\r\n","import { Response } from 'express';\r\n\r\nimport * as tests from './tests';\r\n\r\nexport enum SchemaTest {\r\n  Email = 'email',\r\n  Username = 'username',\r\n  PasswordStrength = 'passwordStrength',\r\n  PhoneNumber = 'phoneNumber',\r\n  IPAddress = 'ipAddress',\r\n  URL = 'url',\r\n}\r\n\r\nexport type SchemaOption = string | number | boolean | null | undefined;\r\n\r\ntype SchemaBaseTypes = 'number' | 'integer' | 'boolean' | 'object' | 'array' | 'image';\r\nexport type SchemaTypes = SchemaBaseTypes | 'string';\r\n\r\nexport interface SchemaItems {\r\n  type: SchemaTypes;\r\n  enum: unknown[];\r\n}\r\n\r\nexport interface SchemaCheck {\r\n  run: ((value: string) => boolean) | ((value: string) => Promise<boolean>);\r\n  response: string;\r\n}\r\n\r\nexport interface BaseSchema<T = unknown> {\r\n  description: string;\r\n  required: boolean;\r\n  options?: SchemaOption[];\r\n  enum?: unknown[];\r\n  items?: SchemaItems;\r\n  min?: number;\r\n  max?: number;\r\n  checks?: SchemaCheck[];\r\n  properties?: T;\r\n  schema?: `{${string}}`;\r\n}\r\n\r\ninterface SchemaWithTest<T> extends BaseSchema<T> {\r\n  type: 'string';\r\n  test?: SchemaTest;\r\n}\r\n\r\ninterface SchemaWithoutTest<T> extends BaseSchema<T> {\r\n  type: SchemaBaseTypes;\r\n}\r\n\r\nexport type Schema = Record<string, SchemaWithTest<Schema> | SchemaWithoutTest<Schema>>;\r\n\r\nexport type SchemaProperty = SchemaWithTest<Schema> | SchemaWithoutTest<Schema>;\r\n\r\n/**\r\n * Validate an object against a schema.\r\n * @param data The object data to validate.\r\n * @param schema The schema to validate against.\r\n * @returns A string if the validation fails, false otherwise.\r\n */\r\nconst validateBase = async (data: Record<string, unknown>, schema: Schema): Promise<string | boolean> => {\r\n  // Check if the data is an object\r\n  if (typeof data !== 'object') return 'The data provided must be an object.';\r\n\r\n  const schemaFields = Object.entries(schema);\r\n\r\n  // Check if all required fields have been provided\r\n  for (const [key, value] of schemaFields) {\r\n    if (value.required && !data[key]) return `The field \"${key}\" has not been provided.`;\r\n  }\r\n\r\n  // Check if all provided fields are the correct type\r\n  for (const [key, value] of schemaFields) {\r\n    if (typeof data[key] !== value.type) return `The field \"${key}\" must be of type ${value.type}.`;\r\n  }\r\n\r\n  // Check if all provided fields are valid\r\n  for (const [key, value] of schemaFields) {\r\n    // Check if the schema value is included in the schema options\r\n    if (value.options && !value.options.includes(data[key] as string | number))\r\n      return `The field \"${key}\" is not a valid option.`;\r\n\r\n    // Number validation\r\n    if (value.type === 'number') {\r\n      // If both min and max are provided, check if the schema value is within the range\r\n      if (\r\n        value.min &&\r\n        value.max &&\r\n        typeof data[key] === 'number' &&\r\n        ((data[key] as number) < value.min || (data[key] as number) > value.max)\r\n      )\r\n        return `The field \"${key}\" must be between ${value.min} and ${value.max}.`;\r\n\r\n      // Check if the schema value is above the minimum required value\r\n      if (value.min && typeof data[key] === 'number' && (data[key] as number) < value.min)\r\n        return `The field \"${key}\" must be at least ${value.min}.`;\r\n\r\n      // Check if the schema value is below the maximum required value\r\n      if (value.max && typeof data[key] === 'number' && (data[key] as number) > value.max)\r\n        return `The field \"${key}\" must be less than ${value.max}.`;\r\n    }\r\n\r\n    // Integer validation\r\n    if (value.type === 'integer') {\r\n      // If both min and max are provided, check if the schema value is within the range\r\n      if (\r\n        value.min &&\r\n        value.max &&\r\n        typeof data[key] === 'number' &&\r\n        ((data[key] as number) < value.min || (data[key] as number) > value.max)\r\n      )\r\n        return `The field \"${key}\" must be between ${value.min} and ${value.max}.`;\r\n\r\n      // Check if the schema value is above the minimum required value\r\n      if (value.min && typeof data[key] === 'number' && (data[key] as number) < value.min)\r\n        return `The field \"${key}\" must be at least ${value.min}.`;\r\n\r\n      // Check if the schema value is below the maximum required value\r\n      if (value.max && typeof data[key] === 'number' && (data[key] as number) > value.max)\r\n        return `The field \"${key}\" must be less than ${value.max}.`;\r\n\r\n      // Check if the schema value is an integer\r\n      if (typeof data[key] !== 'number' || !Number.isInteger(data[key] as number))\r\n        return `The field \"${key}\" must be an integer.`;\r\n    }\r\n\r\n    // String validation\r\n    if (value.type === 'string') {\r\n      const req = value;\r\n      const testVal = data[key] as string;\r\n\r\n      // If both min and max are provided, check if the schema value is within the range\r\n      if (value.min && value.max && (testVal.length < value.min || testVal.length > value.max))\r\n        return `The field \"${key}\" must be between ${value.min} and ${value.max} characters.`;\r\n\r\n      // Check if the schema value has the minimum required length\r\n      if (value.min && testVal.length < value.min)\r\n        return `The field \"${key}\" must be at least ${value.min} characters.`;\r\n\r\n      // Check if the schema value has the maximum required length\r\n      if (value.max && testVal.length > value.max)\r\n        return `The field \"${key}\" must be less than ${value.max} characters.`;\r\n\r\n      // Test if email is valid\r\n      if (req.test === SchemaTest.Email && !tests.email(testVal))\r\n        return `The field \"${key}\" must be a valid email address.`;\r\n\r\n      // Test if username is valid\r\n      if (req.test === SchemaTest.Username && !tests.username(testVal))\r\n        return `The field \"${key}\" must be a valid username.`;\r\n\r\n      // Test if password is valid\r\n      if (req.test === SchemaTest.PasswordStrength && !tests.password(testVal))\r\n        return `The field \"${key}\" is too weak to be a valid password.`;\r\n\r\n      // Test if phone number is valid\r\n      if (req.test === SchemaTest.PhoneNumber && !tests.phone(testVal))\r\n        return `The field \"${key}\" must be a valid phone number.`;\r\n\r\n      // Test if IPv4 address is valid\r\n      if (req.test === SchemaTest.IPAddress && !tests.ipv4Address(testVal))\r\n        return `The field \"${key}\" must be a valid IPv4 address.`;\r\n\r\n      // Test if a url is valid\r\n      if (req.test === SchemaTest.URL && !tests.url(testVal)) return `The field \"${key}\" must be a valid IPv4 address.`;\r\n\r\n      // Test if the schema value is a string\r\n      if (typeof data[key] !== 'string') return `The field \"${key}\" must be a string.`;\r\n    }\r\n\r\n    // Check if the schema value passes all checks\r\n    if (value.checks) {\r\n      for (const check of value.checks) {\r\n        const passedCheck = await check.run(key);\r\n        if (!passedCheck) return `${check.response}.`;\r\n      }\r\n    }\r\n\r\n    // Boolean validation\r\n    if (value.type === 'boolean') {\r\n      // TODO: Check this works\r\n      // Check if the schema value is a boolean\r\n      if (typeof data[key] !== 'boolean') return `The field \"${key}\" must be a boolean.`;\r\n    }\r\n\r\n    // Object validation\r\n    if (value.type === 'object') {\r\n      // TODO: Check this works\r\n      // Check if the schema value is an object\r\n      if (typeof data[key] !== 'object') return `The field \"${key}\" must be an object.`;\r\n\r\n      // Check if the schema value has the correct properties\r\n      if (value.properties) {\r\n        const result = await validateBase(data[key] as Record<string, unknown>, value.properties);\r\n        if (result) return result;\r\n      }\r\n    }\r\n\r\n    // Array validation\r\n    if (value.type === 'array') {\r\n      // TODO: Check this works\r\n      // Check if the schema value is an array\r\n      if (!Array.isArray(data[key])) return `The field \"${key}\" must be an array.`;\r\n\r\n      // Check if the schema value has the correct items\r\n      if (value.items) {\r\n        for (const item of data[key] as unknown[]) {\r\n          if (typeof item !== value.items.type) return `The field \"${key}\" must be an array of ${value.items.type}.`;\r\n          if (!value.items.enum.includes(item)) return `The field \"${key}\" must be an array of valid options.`;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Image validation\r\n    if (value.type === 'image') {\r\n      // TODO: Check this works\r\n      // Check if the schema value is a string\r\n      if (typeof data[key] !== 'string') return `The field \"${key}\" must be a string.`;\r\n\r\n      // Check if the schema value is a valid image\r\n      if (!tests.image(data[key] as string)) return `The field \"${key}\" must be a valid image.`;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Run the validation function, and if the response object is provided, send a response if the validation fails.\r\n * @param data The object data to validate.\r\n * @param schema The schema to validate against.\r\n * @param res The response object.\r\n * @returns A JSON response meaning it's invalid, or null if it's valid.\r\n */\r\nconst validate = async (data: Record<string, unknown>, schema: Schema, res: Response): Promise<Response | null> => {\r\n  const result = await validateBase(data, schema);\r\n  if (result) return res.status(400).json({ status: 400, message: result });\r\n  return null;\r\n};\r\n\r\nexport default validate;\r\n","import { NextFunction, Request, Response } from 'express';\r\nimport { ClientSession, startSession } from 'mongoose';\r\n\r\nimport { logger } from '@utils/index';\r\n\r\ntype ControllerType = (req: Request, res: Response, session: ClientSession) => Promise<unknown> | unknown;\r\n\r\n/**\r\n * Handles a function.\r\n * @param controller The handler function.\r\n * @param req The request.\r\n * @param res The response.\r\n * @param next The next function.\r\n */\r\nconst handledFunction = async (\r\n  controller: ControllerType,\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n): Promise<void> => {\r\n  const session = await startSession();\r\n\r\n  try {\r\n    session.startTransaction();\r\n    await controller(req, res, session);\r\n    await session.commitTransaction();\r\n    next();\r\n  } catch (error) {\r\n    await session.abortTransaction();\r\n    logger.error(error);\r\n    res.status(500).json({ error: 'Internal Server Error' });\r\n  } finally {\r\n    session.endSession();\r\n  }\r\n};\r\n\r\n/**\r\n * Wraps a handler function in error handling.\r\n * @param controller The handler function.\r\n * @returns The handler function wrapped in error handling.\r\n */\r\nexport const withErrorHandling =\r\n  (controller: ControllerType) =>\r\n  (req: Request, res: Response, next: NextFunction): void => {\r\n    handledFunction(controller, req, res, next);\r\n  };\r\n","import { NextFunction, Request, Response } from 'express';\r\n\r\nimport { Schema, logger, validate } from '@utils/index';\r\nimport { withErrorHandling } from '@utils/middleware';\r\nimport { ClientSession } from 'mongoose';\r\n\r\ntype RequestMethod = 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' | 'OPTIONS' | 'HEAD' | 'TRACE' | 'CONNECT';\r\n\r\ntype EndpointMessageType = 'INFO' | 'WARNING' | 'DANGER' | 'SUCCESS';\r\n\r\ninterface EndpointNote {\r\n  type: EndpointMessageType;\r\n  text: string;\r\n}\r\n\r\ntype StatusCode = 200 | 201 | 204 | 301 | 400 | 401 | 403 | 404 | 405 | 409 | 500 | 501;\r\n\r\ninterface EndpointResponse {\r\n  status: StatusCode;\r\n  message: string;\r\n  [key: string]: unknown;\r\n}\r\n\r\n/**\r\n * The endpoint builder class.\r\n */\r\nexport default class EndpointBuilder {\r\n  public disabled: boolean;\r\n  public name: string;\r\n  public description: string;\r\n  public url: `/${string}`;\r\n  public method: RequestMethod;\r\n  public notes: EndpointNote[];\r\n  public paramSchema?: Schema;\r\n  public querySchema?: Schema;\r\n  public bodySchema?: Schema;\r\n  public responses: EndpointResponse[];\r\n  public controller: (req: Request, res: Response, next: NextFunction) => void;\r\n\r\n  /**\r\n   * Creates a new endpoint.\r\n   */\r\n  public constructor() {\r\n    this.disabled = false;\r\n    this.name = 'Name not provided';\r\n    this.description = 'Description not provided';\r\n    this.url = '/';\r\n    this.method = 'GET';\r\n    this.notes = [];\r\n    this.responses = [];\r\n\r\n    /**\r\n     * If the controller is not set, throw an error.\r\n     */\r\n    this.controller = () => {\r\n      throw new Error('Controller not set');\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Sets the disabled state of the endpoint.\r\n   * @param disabled The disabled state of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setDisabled(disabled: boolean): this {\r\n    this.disabled = disabled;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the name of the endpoint.\r\n   * @param name The name of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setName(name: string): this {\r\n    this.name = name;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the description of the endpoint.\r\n   * @param description The description of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setDescription(description: string): this {\r\n    this.description = description;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the url of the endpoint.\r\n   * @param url The url of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setUrl(url: `/${string}`): this {\r\n    this.url = url;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the method of the endpoint.\r\n   * @param method The method of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setMethod(method: RequestMethod): this {\r\n    this.method = method;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the notes of the endpoint.\r\n   * @param notes The notes of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setNotes(notes: EndpointNote[]): this {\r\n    this.notes = notes;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the schema to validate the provided request parameters against.\r\n   * @param prop The schema to be validated against.\r\n   * @param prop.schema The schema to be validated against.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setParamSchema(prop: { schema: Schema }): this {\r\n    this.paramSchema = prop.schema;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the schema to validate the provided request queries against.\r\n   * @param prop The schema to be validated against.\r\n   * @param prop.schema The schema to be validated against.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setQuerySchema(prop: { schema: Schema }): this {\r\n    this.querySchema = prop.schema;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the schema to validate the provided request body against.\r\n   * @param prop The schema to be validated against.\r\n   * @param prop.schema The schema to be validated against.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setBodySchema(prop: { schema: Schema }): this {\r\n    this.bodySchema = prop.schema;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the responses of the endpoint.\r\n   * @param responses The responses of the endpoint.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setResponses(responses: EndpointResponse[]): this {\r\n    this.responses = responses;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the controler to run.\r\n   * @param controller The controlller function to run.\r\n   * @returns The endpoint builder.\r\n   */\r\n  public setController(\r\n    controller: (req: Request, res: Response, session: ClientSession) => Promise<unknown> | unknown\r\n  ): this {\r\n    this.controller = withErrorHandling(controller);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Executes the endpoint function.\r\n   * @param req The request.\r\n   * @param res The response.\r\n   * @param next The next function.\r\n   */\r\n  public execute = (req: Request, res: Response, next: NextFunction): void => {\r\n    (async () => {\r\n      try {\r\n        if (!this.paramSchema && !this.querySchema && !this.bodySchema)\r\n          return res.status(500).json({ status: 500, message: 'Schema not set for endpoint.' });\r\n\r\n        // Validate the request\r\n        if (this.paramSchema && (await validate(req.params, this.paramSchema, res))) return;\r\n        if (this.querySchema && (await validate(req.query, this.querySchema, res))) return;\r\n        if (this.bodySchema && (await validate(req.body as Record<string, unknown>, this.bodySchema, res))) return;\r\n\r\n        // Return the execution of the controller\r\n        return this.controller(req, res, next);\r\n      } catch (error) {\r\n        logger.error(error);\r\n      }\r\n    })();\r\n  };\r\n}\r\n","import { NextFunction, Request, Response, Router } from 'express';\r\n\r\nimport EndpointBuilder from './EndpointBuilder';\r\n\r\ntype Middleware = (req: Request, res: Response, next: NextFunction) => void;\r\n\r\n/**\r\n * The route builder class.\r\n */\r\nexport default class RouteBuilder {\r\n  public raw: Router = Router();\r\n  private route: `/${string}`;\r\n  private name: string;\r\n  private description: string;\r\n  private endpoints: EndpointBuilder[] = [];\r\n  private middlewares: Middleware[] = [];\r\n\r\n  /**\r\n   * Creates a new route builder.\r\n   */\r\n  public constructor() {\r\n    // this.raw = Router();\r\n    this.route = '/';\r\n    this.name = 'Unnamed route';\r\n    this.description = 'No description provided.';\r\n    this.endpoints = [];\r\n  }\r\n\r\n  /**\r\n   * Sets the name of the route.\r\n   * @param name The name of the route.\r\n   * @returns The route builder.\r\n   */\r\n  public setName(name: string): this {\r\n    this.name = name;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the description of the route.\r\n   * @param description The description of the route.\r\n   * @returns The route builder.\r\n   */\r\n  public setDescription(description: string): this {\r\n    this.description = description;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Builds the route.\r\n   * @param route The route to set.\r\n   * @returns The route builder.\r\n   */\r\n  public setRoute(route: `/${string}`): this {\r\n    this.route = route;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a middleware to the route.\r\n   * @param middleware The middleware to add to the route.\r\n   * @returns The route builder.\r\n   */\r\n  public addMiddleware(middleware: Middleware): this {\r\n    this.middlewares.push(middleware);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds an endpoint to the route.\r\n   * @param endpoint The endpoint to add to the route.\r\n   * @returns The route builder.\r\n   */\r\n  public addEndpoint(endpoint: EndpointBuilder): this {\r\n    this.endpoints.push(endpoint);\r\n\r\n    const url: string = `${this.route}${endpoint.url}`.replace('//', '/');\r\n\r\n    switch (endpoint.method) {\r\n      case 'GET':\r\n        this.raw.get(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      case 'POST':\r\n        this.raw.post(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      case 'PUT':\r\n        this.raw.put(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      case 'PATCH':\r\n        this.raw.patch(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      case 'DELETE':\r\n        this.raw.delete(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      case 'OPTIONS':\r\n        this.raw.options(url, ...this.middlewares, endpoint.controller);\r\n        break;\r\n      default:\r\n        throw new Error(`Invalid method ${String(endpoint.method)}`);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds all endpoints from an endpoint file to the route.\r\n   * @param endpointFile The endpoint file to add endpoints from.\r\n   * @returns The route builder.\r\n   */\r\n  public addEndpointFile(endpointFile: Record<string, EndpointBuilder>): this {\r\n    for (const value of Object.values(endpointFile)) {\r\n      this.addEndpoint(value);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Uses a router.\r\n   * @param route The route to use.\r\n   * @param router The router to use.\r\n   * @returns The route builder.\r\n   */\r\n  public use(route: string, router: RouteBuilder): this {\r\n    if (!route) return this;\r\n    // Replace multiple slashes with a single slash.\r\n    const doubleSlashRegex = /\\/+/g;\r\n    // Use the router.\r\n    this.raw.use(route.replace(doubleSlashRegex, '/'), router.raw);\r\n    return this;\r\n  }\r\n}\r\n","import { BaseSchema, Schema, SchemaCheck, SchemaItems, SchemaOption, SchemaTest, SchemaTypes } from '@utils/index';\r\n\r\n/**\r\n * The value builder class.\r\n */\r\nclass ValueBuilder implements BaseSchema {\r\n  public name: string;\r\n  public type: SchemaTypes;\r\n  public typeSchema?: `{${string}}`;\r\n  public description: string;\r\n  public required: boolean;\r\n  public options?: SchemaOption[];\r\n  public enum?: unknown[];\r\n  public items?: SchemaItems;\r\n  public min?: number;\r\n  public max?: number;\r\n  public checks?: SchemaCheck[];\r\n  public properties?: Schema;\r\n  public test?: SchemaTest;\r\n\r\n  /**\r\n   * Sets the name of the value.\r\n   * @param type The type of the value.\r\n   */\r\n  public constructor(type: SchemaTypes) {\r\n    this.name = 'Name not provided';\r\n    this.type = type;\r\n    this.description = 'Description not provided';\r\n    this.required = true; // Default to true\r\n  }\r\n\r\n  /**\r\n   * Sets the type of the value.\r\n   * @param name The name of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setName(name: string): this {\r\n    this.name = name;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the type schema of the value.\r\n   * @param typeSchema The type schema of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setTypeSchema(typeSchema: `{${string}}`): this {\r\n    this.typeSchema = typeSchema;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the description of the value.\r\n   * @param description The description of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setDescription(description: string): this {\r\n    this.description = description;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets whether the value is required.\r\n   * @param required Whether the value is required.\r\n   * @returns The value builder.\r\n   */\r\n  public setRequired(required: boolean): this {\r\n    this.required = required;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the options of the value.\r\n   * @param options The options of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setOptions(options: SchemaOption[]): this {\r\n    this.options = options;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the enum of the value.\r\n   * @param enumValue The enum of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setEnum(enumValue: unknown[]): this {\r\n    this.enum = enumValue;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the items of the value.\r\n   * @param items The items of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setItems(items: SchemaItems): this {\r\n    this.items = items;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the min of the value.\r\n   * @param min The min of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setMin(min: number): this {\r\n    this.min = min;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the max of the value.\r\n   * @param max The max of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setMax(max: number): this {\r\n    this.max = max;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the checks of the value.\r\n   * @param checks The checks of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setChecks(checks: SchemaCheck[]): this {\r\n    this.checks = checks;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the properties of the value.\r\n   * @param properties The properties of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setProperties(properties: Schema): this {\r\n    this.properties = properties;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the test of the value.\r\n   * @param test The test of the value.\r\n   * @returns The value builder.\r\n   */\r\n  public setTest(test: SchemaTest): this {\r\n    this.test = test;\r\n    return this;\r\n  }\r\n}\r\n\r\n/**\r\n * The Schema Builder class.\r\n */\r\nexport default class SchemaBuilder {\r\n  public schema: Schema;\r\n\r\n  /**\r\n   * Creates a new schema.\r\n   */\r\n  public constructor() {\r\n    this.schema = {} as Schema;\r\n  }\r\n\r\n  /**\r\n   * Adds a string value to the schema.\r\n   * @param callback The callback to build the string value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addStringValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('string');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a number value to the schema.\r\n   * @param callback The callback to build the number value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addNumberValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('number');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a integer value to the schema.\r\n   * @param callback The callback to build the integer value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addIntegerValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('integer');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a boolean value to the schema.\r\n   * @param callback The callback to build the boolean value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addBooleanValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('boolean');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a object value to the schema.\r\n   * @param callback The callback to build the object value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addObjectValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('object');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a array value to the schema.\r\n   * @param callback The callback to build the array value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addArrayValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('array');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Adds a image value to the schema.\r\n   * @param callback The callback to build the image value.\r\n   * @returns The schema builder.\r\n   */\r\n  public addImageValue = (callback: (value: ValueBuilder) => void): this => {\r\n    const value = new ValueBuilder('image');\r\n    callback(value);\r\n    this.schema[value.name] = value;\r\n    return this;\r\n  };\r\n}\r\n"],"mappings":"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","names":["dotenv","express","colors","winston","debug","levelColor","level","consoleFormat","timestamp","ms","message","stack","msg","ANSI_REGEX","logger","logger_default","email","str","username","password","phone","ipv4Address","url","image","validateBase","data","schema","schemaFields","key","value","req","testVal","email","username","password","phone","ipv4Address","url","check","result","item","image","validate","res","validate_default","startSession","handledFunction","controller","req","res","next","session","startSession","error","logger_default","withErrorHandling","EndpointBuilder","disabled","name","description","url","method","notes","prop","responses","controller","withErrorHandling","req","res","next","validate_default","error","logger_default","Router","RouteBuilder","name","description","route","middleware","endpoint","url","endpointFile","value","router","doubleSlashRegex","ValueBuilder","type","name","typeSchema","description","required","options","enumValue","items","min","max","checks","properties","test","SchemaBuilder","callback","value","dotenv","src_default","express"]}